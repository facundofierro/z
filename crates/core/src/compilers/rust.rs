use z_ast::{Element, Node};
use super::TargetCompiler;

pub struct RustCompiler;

impl RustCompiler {
    pub fn new() -> Self {
        Self
    }
}

impl TargetCompiler for RustCompiler {
    fn compile(&self, ast: &Element) -> Result<String, String> {
        // For single-file output, just return the main Rust code
        self.generate_main_file(ast)
    }

    fn compile_to_directory(&self, ast: &Element, output_dir: &std::path::Path) -> Option<Result<(), String>> {
        // Create proper Rust project structure using cargo init
        Some(self.create_rust_project(ast, output_dir))
    }

    fn target_name(&self) -> &str {
        "Rust"
    }

    fn file_extension(&self) -> &str {
        "rs"
    }
}

impl RustCompiler {
    fn create_rust_project(&self, ast: &Element, output_dir: &std::path::Path) -> Result<(), String> {
        use std::process::Command;

        let project_name = output_dir.file_name()
            .and_then(|name| name.to_str())
            .unwrap_or("z-generated-rust");

        // Use cargo to initialize a new project
        let status = Command::new("cargo")
            .arg("init")
            .arg("--name")
            .arg(project_name)
            .arg("--bin")
            .current_dir(output_dir)
            .status()
            .map_err(|e| format!("Failed to run cargo init: {}", e))?;

        if !status.success() {
            return Err("cargo init failed".to_string());
        }

        // Customize the generated project with our Z-specific content
        self.customize_rust_project(ast, output_dir)?;

        Ok(())
    }

    fn customize_rust_project(&self, ast: &Element, output_dir: &std::path::Path) -> Result<(), String> {
        use std::fs;

        // Replace src/main.rs with our Z-generated content
        let main_rs_path = output_dir.join("src").join("main.rs");
        fs::write(&main_rs_path, self.generate_main_file(ast)?)
            .map_err(|e| format!("Failed to write src/main.rs: {}", e))?;

        // Add our custom dependencies to Cargo.toml
        let cargo_toml_path = output_dir.join("Cargo.toml");
        let existing_cargo_toml = fs::read_to_string(&cargo_toml_path)
            .map_err(|e| format!("Failed to read Cargo.toml: {}", e))?;

        let enhanced_cargo_toml = self.enhance_cargo_toml(&existing_cargo_toml);
        fs::write(&cargo_toml_path, enhanced_cargo_toml)
            .map_err(|e| format!("Failed to write enhanced Cargo.toml: {}", e))?;

        Ok(())
    }

    fn enhance_cargo_toml(&self, existing_toml: &str) -> String {
        // Parse the existing TOML and add our dependencies
        let mut enhanced = existing_toml.to_string();

        // Add dependencies section if it doesn't exist, or append to existing one
        if !enhanced.contains("[dependencies]") {
            enhanced.push_str("\n[dependencies]\n");
        }

        enhanced.push_str(r#"
# Z Language Runtime Dependencies
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# WebAssembly support (optional)
wasm-bindgen = { version = "0.2", optional = true }
web-sys = { version = "0.3", optional = true }
js-sys = { version = "0.3", optional = true }

[features]
default = []
wasm = ["wasm-bindgen", "web-sys", "js-sys"]
"#);

        enhanced
    }

    fn generate_main_file(&self, ast: &Element) -> Result<String, String> {
        let mut main_rs = String::new();
        main_rs.push_str("// Generated by Z compiler for Rust\n");
        main_rs.push_str("use serde::{Deserialize, Serialize};\n");
        main_rs.push_str("#[cfg(feature = \"wasm\")]\n");
        main_rs.push_str("use wasm_bindgen::prelude::*;\n\n");

        // WebAssembly bindings
        main_rs.push_str("#[cfg(feature = \"wasm\")]\n");
        main_rs.push_str("#[wasm_bindgen]\n");
        main_rs.push_str("extern \"C\" {\n");
        main_rs.push_str("    #[wasm_bindgen(js_namespace = console)]\n");
        main_rs.push_str("    fn log(s: &str);\n");
        main_rs.push_str("}\n\n");

        main_rs.push_str("#[cfg(feature = \"wasm\")]\n");
        main_rs.push_str("macro_rules! console_log {\n");
        main_rs.push_str("    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))\n");
        main_rs.push_str("}\n\n");

        // Generate structs and functions based on AST
        for child in &ast.children {
            if let Node::Element(element) = child {
                match element.name.as_str() {
                    "type" => main_rs.push_str(&self.generate_type_definition(element)),
                    "fun" => main_rs.push_str(&self.generate_function_definition(element)),
                    "mod" => main_rs.push_str(&self.generate_module_definition(element)),
                    _ => main_rs.push_str(&format!("// Unknown element: {}\n", element.name)),
                }
            }
        }

        // Application struct
        main_rs.push_str("#[derive(Debug, Serialize, Deserialize)]\n");
        main_rs.push_str("pub struct ZGeneratedApp {\n");
        main_rs.push_str("    pub name: String,\n");
        main_rs.push_str("    pub version: String,\n");
        main_rs.push_str("}\n\n");

        main_rs.push_str("impl ZGeneratedApp {\n");
        main_rs.push_str("    pub fn new() -> Self {\n");
        main_rs.push_str("        Self {\n");
        main_rs.push_str("            name: \"Z Generated App\".to_string(),\n");
        main_rs.push_str("            version: \"0.1.0\".to_string(),\n");
        main_rs.push_str("        }\n");
        main_rs.push_str("    }\n\n");

        main_rs.push_str("    pub fn run(&self) {\n");
        main_rs.push_str("        println!(\"Running {} v{}\", self.name, self.version);\n");
        main_rs.push_str("        // Application logic here\n");
        main_rs.push_str("    }\n");
        main_rs.push_str("}\n\n");

        // Main function
        main_rs.push_str("#[cfg(not(feature = \"wasm\"))]\n");
        main_rs.push_str("fn main() {\n");
        main_rs.push_str("    println!(\"Welcome to Z Generated Rust Application!\");\n");
        main_rs.push_str("    \n");
        main_rs.push_str("    // Initialize application\n");
        main_rs.push_str("    let app = ZGeneratedApp::new();\n");
        main_rs.push_str("    app.run();\n");
        main_rs.push_str("}\n\n");

        // WebAssembly entry point
        main_rs.push_str("#[cfg(feature = \"wasm\")]\n");
        main_rs.push_str("#[wasm_bindgen(start)]\n");
        main_rs.push_str("pub fn main() {\n");
        main_rs.push_str("    console_log!(\"Z Generated Rust WebAssembly module loaded!\");\n");
        main_rs.push_str("}\n\n");

        // WebAssembly exports
        main_rs.push_str("#[cfg(feature = \"wasm\")]\n");
        main_rs.push_str("#[wasm_bindgen]\n");
        main_rs.push_str("pub fn create_app() -> JsValue {\n");
        main_rs.push_str("    let app = ZGeneratedApp::new();\n");
        main_rs.push_str("    serde_wasm_bindgen::to_value(&app).unwrap()\n");
        main_rs.push_str("}\n");

        Ok(main_rs)
    }

    fn generate_type_definition(&self, _element: &Element) -> String {
        r#"#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZGeneratedType {
    // Type definition placeholder
    pub placeholder: String,
}

"#.to_string()
    }

    fn generate_function_definition(&self, _element: &Element) -> String {
        r#"/// Generated function from Z source
pub fn z_generated_function() -> String {
    "Generated function placeholder".to_string()
}

"#.to_string()
    }

    fn generate_module_definition(&self, _element: &Element) -> String {
        r#"/// Generated module from Z source
pub mod z_generated_module {
    use super::*;

    pub fn module_function() {
        println!("Module function placeholder");
    }
}

"#.to_string()
    }
}