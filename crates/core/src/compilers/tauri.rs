use z_ast::{Element, Node};
use super::TargetCompiler;

pub struct TauriCompiler;

impl TauriCompiler {
    pub fn new() -> Self {
        Self
    }
}

impl TargetCompiler for TauriCompiler {
    fn compile(&self, ast: &Element) -> Result<String, String> {
        // For single-file output, just return the main Rust code
        self.generate_main_rs(ast)
    }

    fn compile_to_directory(&self, ast: &Element, output_dir: &std::path::Path) -> Option<Result<(), String>> {
        // Create proper Tauri project structure using create-tauri-app
        Some(self.create_tauri_project(ast, output_dir))
    }

    fn target_name(&self) -> &str {
        "Tauri"
    }

    fn file_extension(&self) -> &str {
        "rs"
    }
}

impl TauriCompiler {
    fn create_tauri_project(&self, ast: &Element, output_dir: &std::path::Path) -> Result<(), String> {
        use std::fs;
        use std::process::Command;

        let project_name = output_dir.file_name()
            .and_then(|name| name.to_str())
            .unwrap_or("z-generated-tauri");

        // Create Tauri project using create-tauri-app
        let status = Command::new("pnpm")
            .arg("create")
            .arg("tauri-app")
            .arg("--yes")  // Skip prompts
            .arg("--template")
            .arg("vanilla")  // Use vanilla JS template
            .arg(project_name)
            .current_dir(output_dir.parent().unwrap_or(output_dir))
            .status();

        match status {
            Ok(status) if status.success() => {
                // Move the created project to the correct location if needed
                let created_dir = output_dir.parent().unwrap_or(output_dir).join(project_name);
                if created_dir.exists() && created_dir != output_dir {
                    self.move_directory_contents(&created_dir, output_dir)?;
                    fs::remove_dir_all(&created_dir)
                        .map_err(|e| format!("Failed to remove temporary directory: {}", e))?;
                }
            },
            Ok(_) => return Err("Failed to create Tauri project with create-tauri-app".to_string()),
            Err(e) => return Err(format!("Failed to execute create-tauri-app: {}", e)),
        }

        // Customize the generated project with our Z-specific content
        self.customize_tauri_project(ast, output_dir)?;

        Ok(())
    }

    fn move_directory_contents(&self, from: &std::path::Path, to: &std::path::Path) -> Result<(), String> {
        use std::fs;

        for entry in fs::read_dir(from).map_err(|e| format!("Failed to read directory: {}", e))? {
            let entry = entry.map_err(|e| format!("Failed to read directory entry: {}", e))?;
            let file_name = entry.file_name();
            let src = from.join(&file_name);
            let dest = to.join(&file_name);

            if entry.file_type().map_err(|e| format!("Failed to get file type: {}", e))?.is_dir() {
                fs::create_dir_all(&dest).map_err(|e| format!("Failed to create directory: {}", e))?;
                self.move_directory_contents(&src, &dest)?;
            } else {
                fs::copy(&src, &dest).map_err(|e| format!("Failed to copy file: {}", e))?;
            }
        }
        Ok(())
    }

    fn customize_tauri_project(&self, ast: &Element, output_dir: &std::path::Path) -> Result<(), String> {
        use std::fs;

        // Replace src-tauri/src/main.rs with our Z-generated content
        let main_rs_path = output_dir.join("src-tauri").join("src").join("main.rs");
        fs::write(&main_rs_path, self.generate_main_rs(ast)?)
            .map_err(|e| format!("Failed to write src-tauri/src/main.rs: {}", e))?;

        // Replace frontend main.js with our Z-generated content
        let main_js_path = output_dir.join("main.js");
        fs::write(&main_js_path, self.generate_main_js(ast)?)
            .map_err(|e| format!("Failed to write main.js: {}", e))?;

        Ok(())
    }

    fn generate_main_rs(&self, ast: &Element) -> Result<String, String> {
        let mut main_rs = String::new();
        main_rs.push_str("// Generated by Z compiler for Tauri backend\n");
        main_rs.push_str("#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\n");
        main_rs.push_str("use tauri::{command, State, Manager};\n");
        main_rs.push_str("use serde::{Deserialize, Serialize};\n");
        main_rs.push_str("use std::sync::Mutex;\n\n");

        // Generate commands based on AST
        for child in &ast.children {
            if let Node::Element(element) = child {
                match element.name.as_str() {
                    "Backend" => main_rs.push_str(&self.generate_backend_commands(element)),
                    "Config" => main_rs.push_str(&self.generate_config_struct(element)),
                    _ => {},
                }
            }
        }

        // App state
        main_rs.push_str("#[derive(Debug, Serialize, Deserialize, Clone)]\n");
        main_rs.push_str("pub struct AppState {\n");
        main_rs.push_str("    pub name: String,\n");
        main_rs.push_str("    pub version: String,\n");
        main_rs.push_str("    pub counter: i32,\n");
        main_rs.push_str("}\n\n");

        main_rs.push_str("impl Default for AppState {\n");
        main_rs.push_str("    fn default() -> Self {\n");
        main_rs.push_str("        Self {\n");
        main_rs.push_str("            name: \"Z Generated Tauri App\".to_string(),\n");
        main_rs.push_str("            version: \"0.1.0\".to_string(),\n");
        main_rs.push_str("            counter: 0,\n");
        main_rs.push_str("        }\n");
        main_rs.push_str("    }\n");
        main_rs.push_str("}\n\n");

        // Tauri commands
        main_rs.push_str("#[command]\n");
        main_rs.push_str("async fn get_app_state(state: State<'_, Mutex<AppState>>) -> Result<AppState, String> {\n");
        main_rs.push_str("    let app_state = state.lock().map_err(|e| e.to_string())?;\n");
        main_rs.push_str("    Ok(app_state.clone())\n");
        main_rs.push_str("}\n\n");

        main_rs.push_str("#[command]\n");
        main_rs.push_str("async fn increment_counter(state: State<'_, Mutex<AppState>>) -> Result<i32, String> {\n");
        main_rs.push_str("    let mut app_state = state.lock().map_err(|e| e.to_string())?;\n");
        main_rs.push_str("    app_state.counter += 1;\n");
        main_rs.push_str("    Ok(app_state.counter)\n");
        main_rs.push_str("}\n\n");

        main_rs.push_str("#[command]\n");
        main_rs.push_str("async fn greet(name: &str) -> Result<String, String> {\n");
        main_rs.push_str("    Ok(format!(\"Hello, {}! You've been greeted from Rust!\", name))\n");
        main_rs.push_str("}\n\n");

        // Main function
        main_rs.push_str("fn main() {\n");
        main_rs.push_str("    tauri::Builder::default()\n");
        main_rs.push_str("        .manage(Mutex::new(AppState::default()))\n");
        main_rs.push_str("        .invoke_handler(tauri::generate_handler![get_app_state, increment_counter, greet])\n");
        main_rs.push_str("        .setup(|app| {\n");
        main_rs.push_str("            // Additional setup logic here\n");
        main_rs.push_str("            println!(\"Z Generated Tauri app started!\");\n");
        main_rs.push_str("            Ok(())\n");
        main_rs.push_str("        })\n");
        main_rs.push_str("        .run(tauri::generate_context!())\n");
        main_rs.push_str("        .expect(\"error while running tauri application\");\n");
        main_rs.push_str("}\n");

        Ok(main_rs)
    }

    fn generate_backend_commands(&self, _element: &Element) -> String {
        r#"// Backend commands placeholder
#[command]
async fn backend_operation() -> Result<String, String> {
    Ok("Backend operation completed".to_string())
}

"#.to_string()
    }

    fn generate_config_struct(&self, _element: &Element) -> String {
        r#"#[derive(Debug, Serialize, Deserialize)]
pub struct AppConfig {
    pub theme: String,
    pub auto_save: bool,
}

impl Default for AppConfig {
    fn default() -> Self {
        Self {
            theme: "dark".to_string(),
            auto_save: true,
        }
    }
}

"#.to_string()
    }

    fn generate_main_js(&self, ast: &Element) -> Result<String, String> {
        let mut main_js = String::new();
        main_js.push_str("// Generated by Z compiler for Tauri frontend\n");
        main_js.push_str("import { invoke } from '@tauri-apps/api/tauri';\n\n");

        main_js.push_str("let counter = 0;\n\n");

        // Generate frontend logic based on AST
        for child in &ast.children {
            if let Node::Element(element) = child {
                if element.name == "Frontend" {
                    main_js.push_str(&self.generate_frontend_logic(element));
                }
            }
        }

        main_js.push_str("// Initialize the app\n");
        main_js.push_str("document.addEventListener('DOMContentLoaded', async () => {\n");
        main_js.push_str("  const counterEl = document.getElementById('counter');\n");
        main_js.push_str("  const incrementBtn = document.getElementById('increment-btn');\n");
        main_js.push_str("  const greetBtn = document.getElementById('greet-btn');\n");
        main_js.push_str("  const statusEl = document.getElementById('status');\n\n");

        main_js.push_str("  // Load initial state\n");
        main_js.push_str("  try {\n");
        main_js.push_str("    const state = await invoke('get_app_state');\n");
        main_js.push_str("    counter = state.counter;\n");
        main_js.push_str("    if (counterEl) counterEl.textContent = counter;\n");
        main_js.push_str("    if (statusEl) statusEl.textContent = `${state.name} v${state.version} loaded`;\n");
        main_js.push_str("  } catch (error) {\n");
        main_js.push_str("    if (statusEl) statusEl.textContent = `Error: ${error}`;\n");
        main_js.push_str("  }\n\n");

        main_js.push_str("  // Increment counter\n");
        main_js.push_str("  if (incrementBtn) {\n");
        main_js.push_str("    incrementBtn.addEventListener('click', async () => {\n");
        main_js.push_str("      try {\n");
        main_js.push_str("        counter = await invoke('increment_counter');\n");
        main_js.push_str("        if (counterEl) counterEl.textContent = counter;\n");
        main_js.push_str("        if (statusEl) statusEl.textContent = `Counter incremented to ${counter}`;\n");
        main_js.push_str("      } catch (error) {\n");
        main_js.push_str("        if (statusEl) statusEl.textContent = `Error: ${error}`;\n");
        main_js.push_str("      }\n");
        main_js.push_str("    });\n");
        main_js.push_str("  }\n\n");

        main_js.push_str("  // Greet button\n");
        main_js.push_str("  if (greetBtn) {\n");
        main_js.push_str("    greetBtn.addEventListener('click', async () => {\n");
        main_js.push_str("      try {\n");
        main_js.push_str("        const greeting = await invoke('greet', { name: 'Z User' });\n");
        main_js.push_str("        if (statusEl) statusEl.textContent = greeting;\n");
        main_js.push_str("      } catch (error) {\n");
        main_js.push_str("        if (statusEl) statusEl.textContent = `Error: ${error}`;\n");
        main_js.push_str("      }\n");
        main_js.push_str("    });\n");
        main_js.push_str("  }\n");
        main_js.push_str("});\n");

        Ok(main_js)
    }

    fn generate_frontend_logic(&self, _element: &Element) -> String {
        "// Frontend logic placeholder\n".to_string()
    }
}